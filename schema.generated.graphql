# THIS FILE IS AUTO-GENERATED, DO NOT MODIFY.
# The source of truth is the API server
# To re-generate, ensure the server is running on port 30001
# and execute: yarn gql:gen
#
schema {
  query: Query
  mutation: Mutation
}

type Account {
  accountNumber: String
  active: Boolean!
  annualInterestRate: Float
  bookId: ID!
  cardNumber: String
  createdAt: ISO8601DateTime!
  creditLimit: Int
  currencyIsoCode: String!
  defaultCategoryId: ID
  expiresAt: ISO8601Date
  iban: String
  id: ID!
  importOrigin: ImportOrigin
  initialBalance: Int!
  institutionName: String
  name: String!
  notes: String
  parentId: ID
  startsAt: ISO8601Date
  type: AccountType!
}

input AccountForCreateInput {
  accountNumber: String
  active: Boolean!
  annualInterestRate: Float
  bookId: ID!
  cardNumber: String
  creditLimit: Int
  currencyIsoCode: String!
  defaultCategoryId: ID
  expiresAt: ISO8601Date
  iban: String
  id: ID
  importOrigin: ImportOriginInput
  initialBalance: Int!
  institutionName: String
  name: String!
  notes: String
  parentId: ID
  startsAt: ISO8601Date
  type: AccountType!
}

enum AccountType {
  Asset
  Bank
  Card
  Institution
  Investment
  Liability
  Loan
}

type Book {
  createdAt: ISO8601DateTime!
  defaultCurrencyIsoCode: String!
  id: ID!
  importOrigin: ImportOrigin
  name: String!
  owner: User!
  ownerId: ID!
}

"""The connection type for Book."""
type BookConnection {
  """A list of edges."""
  edges: [BookEdge]
  """A list of nodes."""
  nodes: [Book]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BookEdge {
  """A cursor for use in pagination."""
  cursor: String!
  """The item at the end of the edge."""
  node: Book
}

input BookForCreateInput {
  defaultCurrencyIsoCode: String!
  id: ID
  name: String!
}

type Category {
  active: Boolean!
  bookId: ID!
  currencyIsoCode: String!
  id: ID!
  importOrigin: ImportOrigin
  """Indicates if the category is income (true) or expense (false)."""
  income: Boolean!
  name: String!
  notes: String
  parentId: ID
}

input CategoryForCreateInput {
  active: Boolean!
  bookId: ID!
  currencyIsoCode: String!
  id: ID
  importOrigin: ImportOriginInput
  """Indicates if the category is income (true) or expense (false)."""
  income: Boolean!
  name: String!
  notes: String
  parentId: ID
}

"""Autogenerated input type of CreateAccount"""
input CreateAccountInput {
  account: AccountForCreateInput!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of CreateAccount."""
type CreateAccountPayload {
  account: Account!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateBook"""
input CreateBookInput {
  book: BookForCreateInput!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of CreateBook."""
type CreateBookPayload {
  book: Book!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateCategory"""
input CreateCategoryInput {
  category: CategoryForCreateInput!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of CreateCategory."""
type CreateCategoryPayload {
  category: Category!
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateExchange"""
input CreateExchangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  exchange: ExchangeForCreateInput!
}

"""Autogenerated return type of CreateExchange."""
type CreateExchangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  exchange: Exchange!
}

"""Autogenerated input type of CreateReminder"""
input CreateReminderInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  reminder: ReminderForCreateInput!
}

"""Autogenerated return type of CreateReminder."""
type CreateReminderPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  reminder: Reminder!
}

type Exchange {
  cheque: String
  createdAt: ISO8601DateTime!
  date: ISO8601Date!
  description: String!
  id: ID!
  importOrigin: ImportOrigin
  memo: String
  registerId: ID!
  splits: [Split!]!
  status: ExchangeStatus!
  tags: [String!]
  updatedAt: ISO8601DateTime!
}

input ExchangeForCreateInput {
  cheque: String
  createdAt: ISO8601DateTime
  date: ISO8601Date!
  description: String!
  id: ID
  importOrigin: ImportOriginInput
  memo: String
  registerId: ID!
  splits: [SplitForCreateInput!]!
  status: ExchangeStatus
  tags: [String!]
}

enum ExchangeStatus {
  cleared
  reconciling
  uncleared
}

"""An ISO 8601-encoded date"""
scalar ISO8601Date

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

type ImportOrigin {
  id: String!
  system: String!
}

input ImportOriginInput {
  id: String!
  system: String!
}

"""Represents untyped JSON"""
scalar JSON

"""Autogenerated input type of LogIn"""
input LogInInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
  password: String!
}

"""Autogenerated return type of LogIn."""
type LogInPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
  user: User!
}

"""Autogenerated input type of LogOut"""
input LogOutInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of LogOut."""
type LogOutPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type Mutation {
  createAccount(
    """Parameters for CreateAccount"""
    input: CreateAccountInput!
  ): CreateAccountPayload
  createBook(
    """Parameters for CreateBook"""
    input: CreateBookInput!
  ): CreateBookPayload
  createCategory(
    """Parameters for CreateCategory"""
    input: CreateCategoryInput!
  ): CreateCategoryPayload
  createExchange(
    """Parameters for CreateExchange"""
    input: CreateExchangeInput!
  ): CreateExchangePayload
  createReminder(
    """Parameters for CreateReminder"""
    input: CreateReminderInput!
  ): CreateReminderPayload
  logIn(
    """Parameters for LogIn"""
    input: LogInInput!
  ): LogInPayload
  logOut(
    """Parameters for LogOut"""
    input: LogOutInput!
  ): LogOutPayload
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Query {
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: String
    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    """Returns the first _n_ elements from the list."""
    first: Int
    """Returns the last _n_ elements from the list."""
    last: Int
  ): BookConnection!
  me: User
}

type Reminder {
  bookId: ID!
  description: String
  exchangeDescription: String!
  exchangeMemo: String
  exchangeRegisterId: ID!
  exchangeStatus: ExchangeStatus!
  firstDate: ISO8601Date!
  id: ID!
  lastCommitAt: ISO8601Date
  lastDate: ISO8601Date
  mode: ReminderMode!
  nextOccurenceAt: ISO8601Date
  recurrence: JSON
  splits: [ReminderSplit!]!
  tags: [String!]!
  title: String!
}

input ReminderForCreateInput {
  bookId: ID!
  description: String
  exchangeDescription: String!
  exchangeMemo: String
  exchangeRegisterId: ID!
  exchangeStatus: ExchangeStatus!
  firstDate: ISO8601Date!
  id: ID
  importOrigin: ImportOriginInput
  lastCommitAt: ISO8601Date
  lastDate: ISO8601Date
  mode: ReminderMode!
  recurrence: JSON!
  splits: [ReminderSplitInput!]!
  title: String!
}

enum ReminderMode {
  auto_cancel
  auto_commit
  manual
}

type ReminderSplit {
  amount: Int!
  counterpartAmount: Int
  id: ID!
  memo: String
  registerId: ID!
  status: ExchangeStatus!
  tags: [String!]!
}

input ReminderSplitInput {
  amount: Int!
  counterpartAmount: Int
  id: ID
  importOrigin: ImportOriginInput
  memo: String
  registerId: ID!
  status: ExchangeStatus
  tags: [String!]
}

type Split {
  amount: Int!
  counterpartAmount: Int
  createdAt: ISO8601DateTime!
  exchangeId: ID!
  id: ID!
  importOrigin: ImportOrigin
  memo: String
  registerId: ID!
  status: ExchangeStatus!
  tags: [String!]
  updatedAt: ISO8601DateTime!
}

input SplitForCreateInput {
  amount: Int!
  counterpartAmount: Int!
  createdAt: ISO8601DateTime
  id: ID
  importOrigin: ImportOriginInput
  memo: String
  registerId: ID!
  status: ExchangeStatus
  tags: [String!]
}

type User {
  displayName: String!
  email: String!
}