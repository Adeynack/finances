# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `montrose` gem.
# Please instead update this file by running `bin/tapioca gem montrose`.

# source://montrose//lib/montrose/version.rb#3
module Montrose
  extend ::Montrose::Chainable

  class << self
    # Create a new recurrence from given options
    # An alias to {Montrose::Recurrence.new}
    #
    # source://montrose//lib/montrose.rb#57
    def enable_deprecated_between_masking; end

    # source://montrose//lib/montrose.rb#59
    def enable_deprecated_between_masking=(value); end

    # @return [Boolean]
    #
    # source://montrose//lib/montrose.rb#64
    def enable_deprecated_between_masking?; end

    # Create a new recurrence from given options
    # An alias to {Montrose::Recurrence.new}
    #
    # @example
    #   Montrose.recurrence(every: :day)
    #   Montrose.r(every: :day)
    # @param options [Hash] recurrence options
    # @return [Montrose::Recurrence]
    #
    # source://montrose//lib/montrose.rb#50
    def r(options = T.unsafe(nil)); end

    # Create a new recurrence from given options
    # An alias to {Montrose::Recurrence.new}
    #
    # @example
    #   Montrose.recurrence(every: :day)
    #   Montrose.r(every: :day)
    # @param options [Hash] recurrence options
    # @return [Montrose::Recurrence]
    #
    # source://montrose//lib/montrose.rb#50
    def recurrence(options = T.unsafe(nil)); end
  end
end

# source://montrose//lib/montrose/chainable.rb#6
module Montrose::Chainable
  # Create a recurrence at given time
  #
  # @example
  #   Montrose.daily.at("12pm")
  #   Montrose.daily.at("9:37am")
  # @param time [String, Time] represents time of day
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#228
  def at(time); end

  # Create a recurrence occurring between the start and end
  # of a given date range; :between is shorthand for separate
  # :starts and :until options. When used with explicit :start
  # and/or :until options, those will take precedence.
  #
  # @example
  #   Montrose.weekly.between(Date.today..Date.new(2016, 3, 15))
  # @param date_range [Range<Date>]
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#169
  def between(date_range); end

  # @private
  #
  # source://montrose//lib/montrose/chainable.rb#372
  def branch(options); end

  # Create a recurrence which will only emit values within the
  # date range, also called "masking."
  #
  # @example
  #   Montrose.weekly.covering(Date.tomorrow..Date.new(2016, 3, 15))
  # @param date_range [Range<Date>]
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#183
  def covering(date_range); end

  # Create a daily recurrence.
  #
  # @example
  #   Montrose.daily
  #   Montrose.daily(interval: 2) #=> every 2 days
  #   Montrose.daily(starts: 3.days.from_now)
  #   Montrose.daily(until: 10.days.from_now)
  #   Montrose.daily(total: 5)
  #   Montrose.daily(except: Date.tomorrow)
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#76
  def daily(options = T.unsafe(nil)); end

  # Create a recurrence for given days of week
  #
  # @example
  #   Montrose.daily.day_of_week(:saturday)
  #   Montrose.daily.day_of_week(:monday, :tuesday)
  #   Montrose.daily.day_of_week(2..5)
  # @param weekdays [Symbol] days of week, e.g. :sunday, :monday, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#273
  def day(weekdays, *extras); end

  # Create a recurrence for given days of month
  #
  # @example
  #   Montrose.daily.day_of_month(1, -1)
  #   Montrose.daily.day_of_month([1, -1])
  #   Montrose.daily.day_of_month(2..8)
  # @param days [Fixnum] days of month, e.g. 1, 2, -1, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#257
  def day_of_month(days, *extras); end

  # Create a recurrence for given days of week
  #
  # @example
  #   Montrose.daily.day_of_week(:saturday)
  #   Montrose.daily.day_of_week(:monday, :tuesday)
  #   Montrose.daily.day_of_week(2..5)
  # @param weekdays [Symbol] days of week, e.g. :sunday, :monday, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#273
  def day_of_week(weekdays, *extras); end

  # Create a recurrence for given days of year
  #
  # @example
  #   Montrose.daily.day_of_year(1, 10, 100)
  #   Montrose.daily.day_of_year([1, 10, 100])
  #   Montrose.daily.day_of_year(20..50)
  # @param days [Fixnum, Range, Array<Integer>] days of year, e.g., 1, 10, 100, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#289
  def day_of_year(days, *extras); end

  # @private
  #
  # source://montrose//lib/montrose/chainable.rb#377
  def default_options; end

  # Create a recurrence occurring within a time-of-day range or ranges.
  # Given time ranges will parse as times-of-day and ignore given dates.
  #
  # @example
  #   Montrose.every(20.minutes).during("9am-5pm")
  #   Montrose.every(20.minutes).during(time.change(hour: 9)..time.change(hour: 5))
  #   Montrose.every(20.minutes).during([9, 0, 0], [17, 0, 0])
  #   Montrose.every(20.minutes).during("9am-12pm", "1pm-5pm")
  # @param time-of-day [Range<Time>, String, Array<Array>] range(s)
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#200
  def during(time_of_day, *extras); end

  # Create a recurrence ending at given timestamp.
  #
  # @example
  #   Montrose.daily.ending(1.year.from_now)
  # @param ends_at [Time, Date] end time of recurrence
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#152
  def ending(ends_at); end

  # Create a recurrence from the given frequency
  #
  # @example
  #   Montrose.every(:hour)
  #   Montrose.every(:hour, interval: 2)
  #   Montrose.every(3.days, starts: 2.days.from_now)
  #   Montrose.every(1.year, until: 10.days.from_now)
  # @param frequency [Symbol, String, Numeric] the recurrence frequency
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#22
  def every(frequency, options = T.unsafe(nil)); end

  # Create a recurrence with dates except dates given
  #
  # @example
  #   Montrose.daily.except("2016-03-01")
  #   Montrose.daily.except(Date.today)
  # @param date [String, Date] represents date
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#242
  def except(date); end

  # Create a recurrence for given hours of day
  #
  # @example
  #   Montrose.hourly.hour_of_day(9)
  #   Montrose.hourly.hour_of_day(15)
  #   Montrose.hourly.hour_of_day(6..10)
  # @param hours [Fixnum, Range, Array<Integer>] hours of day, e.g. 1, 10, 100, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#305
  def hour(hours, *extras); end

  # Create a recurrence for given hours of day
  #
  # @example
  #   Montrose.hourly.hour_of_day(9)
  #   Montrose.hourly.hour_of_day(15)
  #   Montrose.hourly.hour_of_day(6..10)
  # @param hours [Fixnum, Range, Array<Integer>] hours of day, e.g. 1, 10, 100, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#305
  def hour_of_day(hours, *extras); end

  # Create a hourly recurrence.
  #
  # @example
  #   Montrose.hourly
  #   Montrose.hourly(interval: 2) #=> every 2 hours
  #   Montrose.hourly(starts: 3.days.from_now)
  #   Montrose.hourly(until: 10.days.from_now)
  #   Montrose.hourly(total: 5)
  #   Montrose.hourly(except: Date.tomorrow)
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#58
  def hourly(options = T.unsafe(nil)); end

  # Create a recurrence for given days of month
  #
  # @example
  #   Montrose.daily.day_of_month(1, -1)
  #   Montrose.daily.day_of_month([1, -1])
  #   Montrose.daily.day_of_month(2..8)
  # @param days [Fixnum] days of month, e.g. 1, 2, -1, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#257
  def mday(days, *extras); end

  # Create a new recurrence combining options of self
  # and other. The value of entries with duplicate
  # keys will be those of other
  #
  # @example
  #   Montrose.daily.total(10)
  # @param other [Hash, Montrose::Recurrence] other options or recurrence
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#367
  def merge(other = T.unsafe(nil)); end

  # Create a minutely recurrence.
  #
  # @example
  #   Montrose.minutely
  #   Montrose.minutely(interval: 2) #=> every 2 minutes
  #   Montrose.minutely(starts: 3.days.from_now)
  #   Montrose.minutely(until: 10.days.from_now)
  #   Montrose.minutely(total: 5)
  #   Montrose.minutely(except: Date.tomorrow)
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#40
  def minutely(options = T.unsafe(nil)); end

  # Create a recurrence for given months of year
  #
  # @example
  #   Montrose.monthly.month_of_year(9)
  #   Montrose.monthly.month_of_year([2, 5])
  #   Montrose.monthly.month_of_year(2..5)
  # @param months [Fixnum, Symbol] months of year, e.g., :january, :april, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#321
  def month(months, *extras); end

  # Create a recurrence for given months of year
  #
  # @example
  #   Montrose.monthly.month_of_year(9)
  #   Montrose.monthly.month_of_year([2, 5])
  #   Montrose.monthly.month_of_year(2..5)
  # @param months [Fixnum, Symbol] months of year, e.g., :january, :april, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#321
  def month_of_year(months, *extras); end

  # Create a monthly recurrence.
  #
  # @example
  #   Montrose.monthly(mday: [2, 15]) # 2nd and 15th of the month
  #   Montrose.monthly(mday: -3) # third-to-last day of the month
  #   Montrose.monthly(mday: 10..15) # 10th through the 15th day of the month
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#108
  def monthly(options = T.unsafe(nil)); end

  # Create a recurrence through :on option
  #
  # @example
  #   Montrose.weekly.on(:friday)
  #   Montrose.monthly.on(friday: 13)
  # @param day [Hash, Symbol] weekday or day of month as hash, e.g. { friday: 13 }
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#214
  def on(day); end

  # Create a recurrence that ends after given number
  # of occurrences
  #
  # @example
  #   Montrose.daily.total(10)
  # @param total [Fixnum] repeat count
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#351
  def repeat(total); end

  # Create a recurrence starting at given timestamp.
  #
  # @example
  #   Montrose.daily.starting(Date.tomorrow)
  # @param starts_at [Time, Date] start time of recurrence
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#138
  def starting(starts_at); end

  # Create a recurrence starting at given timestamp.
  #
  # @example
  #   Montrose.daily.starting(Date.tomorrow)
  # @param starts_at [Time, Date] start time of recurrence
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#138
  def starts(starts_at); end

  # Create a recurrence that ends after given number
  # of occurrences
  #
  # @example
  #   Montrose.daily.total(10)
  # @param total [Fixnum] repeat count
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#351
  def total(total); end

  # Create a recurrence ending at given timestamp.
  #
  # @example
  #   Montrose.daily.ending(1.year.from_now)
  # @param ends_at [Time, Date] end time of recurrence
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#152
  def until(ends_at); end

  # Create a recurrence for given weeks of year
  #
  # @example
  #   Montrose.weekly.week_of_year(9)
  #   Montrose.weekly.week_of_year([2, 5])
  #   Montrose.weekly.week_of_year(2..5)
  # @param weeks [Fixnum] weeks of year, e.g., 1, 20, 50
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#337
  def week_of_year(weeks, *extras); end

  # Create a weekly recurrence.
  #
  # @example
  #   Montrose.weekly(on: 5) #=> 0 = sunday, 1 = monday, ...
  #   Montrose.weekly(on: :saturday)
  #   Montrose.weekly(on: [sunday, :saturday])
  #   Montrose.weekly(on: :saturday, interval: 2)
  #   Montrose.weekly(on: :saturday, total: 5)
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#93
  def weekly(options = T.unsafe(nil)); end

  # Create a recurrence for given days of year
  #
  # @example
  #   Montrose.daily.day_of_year(1, 10, 100)
  #   Montrose.daily.day_of_year([1, 10, 100])
  #   Montrose.daily.day_of_year(20..50)
  # @param days [Fixnum, Range, Array<Integer>] days of year, e.g., 1, 10, 100, ...
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#289
  def yday(days, *extras); end

  # Create a yearly recurrence.
  #
  # @example
  #   Montrose.yearly(on: [7, 14]) #=> every Jul 14
  #   Montrose.yearly(on: [7, 14], interval: 2) #=> every 2 years on Jul 14
  #   Montrose.yearly(on: [:jan, 14], interval: 2)
  #   Montrose.yearly(on: [:january, 14], interval: 2)
  #   Montrose.yearly(on: [:january, 14], total: 5)
  # @param options [Hash] additional recurrence options
  # @return [Montrose::Recurrence]
  #
  # source://montrose//lib/montrose/chainable.rb#125
  def yearly(options = T.unsafe(nil)); end
end

# source://montrose//lib/montrose/clock.rb#6
class Montrose::Clock
  # @return [Clock] a new instance of Clock
  #
  # source://montrose//lib/montrose/clock.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://montrose//lib/montrose/clock.rb#23
  def peek; end

  # Advances time to new unit by increment and sets
  # new time as "current" time for next tick
  #
  # source://montrose//lib/montrose/clock.rb#19
  def tick; end

  private

  # source://montrose//lib/montrose/clock.rb#39
  def advance_step(time); end

  # source://montrose//lib/montrose/clock.rb#47
  def smallest_step; end

  # source://montrose//lib/montrose/clock.rb#43
  def step; end

  # Change 'unit' to :units
  #
  # @private
  #
  # source://montrose//lib/montrose/clock.rb#89
  def step_key(unit); end

  # Returns hash representing unit and amount to advance time
  # when options contain given unit as a key or as a value of
  # the key :every in options
  #
  # options = { every: :day, hour: 8.12 }
  # unit_step(:minute)
  # => nil
  # unit_step(:hour)
  # => { hour: 1 }
  #
  # options = { every: :hour, interval: 6 }
  # unit_step(:minute)
  # => nil
  # unit_step(:hour)
  # => { hour: 6 }
  #
  # @private
  #
  # source://montrose//lib/montrose/clock.rb#75
  def unit_step(unit, *alternates); end
end

# source://montrose//lib/montrose/errors.rb#5
class Montrose::ConfigurationError < ::Montrose::Error; end

# source://montrose//lib/montrose/day.rb#2
class Montrose::Day
  extend ::Montrose::Utils

  class << self
    # source://montrose//lib/montrose/day.rb#78
    def abbreviations; end

    # source://montrose//lib/montrose/day.rb#44
    def map_arg(arg, &block); end

    # source://montrose//lib/montrose/day.rb#50
    def names; end

    # source://montrose//lib/montrose/day.rb#54
    def number(name); end

    # source://montrose//lib/montrose/day.rb#69
    def number!(name); end

    # source://montrose//lib/montrose/day.rb#74
    def numbers; end

    # source://montrose//lib/montrose/day.rb#13
    def parse(arg); end

    # source://montrose//lib/montrose/day.rb#24
    def parse_entries(entries); end

    # source://montrose//lib/montrose/day.rb#37
    def parse_ical(value); end

    # source://montrose//lib/montrose/day.rb#33
    def parse_value(value); end
  end
end

# e.g. 1FR
#
# source://montrose//lib/montrose/day.rb#10
Montrose::Day::ICAL_MATCH = T.let(T.unsafe(nil), Regexp)

# source://montrose//lib/montrose/day.rb#5
Montrose::Day::NAMES = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/day.rb#8
Montrose::Day::NUMBERS = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/day.rb#7
Montrose::Day::THREE_LETTER_ABBREVIATIONS = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/day.rb#6
Montrose::Day::TWO_LETTER_ABBREVIATIONS = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/errors.rb#4
class Montrose::Error < ::StandardError; end

# Abstract class for special recurrence rule required
# in all instances of Recurrence. Frequency describes
# the base recurrence interval.
#
# source://montrose//lib/montrose/frequency.rb#8
class Montrose::Frequency
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # @return [Frequency] a new instance of Frequency
  #
  # source://montrose//lib/montrose/frequency.rb#89
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency.rb#96
  def matches_interval?(time_diff); end

  # Returns the value of attribute starts.
  #
  # source://montrose//lib/montrose/frequency.rb#31
  def starts; end

  # Returns the value of attribute time.
  #
  # source://montrose//lib/montrose/frequency.rb#31
  def time; end

  # source://montrose//lib/montrose/frequency.rb#100
  def to_cron; end

  protected

  # source://montrose//lib/montrose/frequency.rb#106
  def interval_str; end

  class << self
    # @private
    #
    # source://montrose//lib/montrose/frequency.rb#65
    def assert(frequency); end

    # @private
    #
    # source://montrose//lib/montrose/frequency.rb#84
    def duration_to_frequency_parts(duration); end

    # Factory method for instantiating the appropriate Frequency
    # subclass.
    #
    # source://montrose//lib/montrose/frequency.rb#49
    def from_options(opts); end

    # source://montrose//lib/montrose/frequency.rb#58
    def from_term(term); end

    # @private
    #
    # source://montrose//lib/montrose/frequency.rb#73
    def numeric_to_frequency_parts(number); end

    # source://montrose//lib/montrose/frequency.rb#34
    def parse(input); end
  end
end

# source://montrose//lib/montrose/frequency/daily.rb#5
class Montrose::Frequency::Daily < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/daily.rb#6
  def include?(time); end

  # source://montrose//lib/montrose/frequency/daily.rb#10
  def to_cron; end
end

# source://montrose//lib/montrose/frequency.rb#29
Montrose::Frequency::FREQUENCY_KEYS = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/frequency.rb#19
Montrose::Frequency::FREQUENCY_TERMS = T.let(T.unsafe(nil), Hash)

# source://montrose//lib/montrose/frequency/hourly.rb#5
class Montrose::Frequency::Hourly < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/hourly.rb#6
  def include?(time); end

  # source://montrose//lib/montrose/frequency/hourly.rb#10
  def to_cron; end
end

# source://montrose//lib/montrose/frequency/minutely.rb#5
class Montrose::Frequency::Minutely < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/minutely.rb#6
  def include?(time); end
end

# source://montrose//lib/montrose/frequency/monthly.rb#5
class Montrose::Frequency::Monthly < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/monthly.rb#6
  def include?(time); end

  # source://montrose//lib/montrose/frequency/monthly.rb#10
  def to_cron; end
end

# source://montrose//lib/montrose/frequency/secondly.rb#5
class Montrose::Frequency::Secondly < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/secondly.rb#6
  def include?(time); end
end

# source://montrose//lib/montrose/frequency/weekly.rb#5
class Montrose::Frequency::Weekly < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/weekly.rb#6
  def include?(time); end

  # source://montrose//lib/montrose/frequency/weekly.rb#10
  def to_cron; end

  private

  # source://montrose//lib/montrose/frequency/weekly.rb#22
  def base_date; end

  # source://montrose//lib/montrose/frequency/weekly.rb#18
  def weeks_since_start(time); end
end

# source://montrose//lib/montrose/frequency/yearly.rb#5
class Montrose::Frequency::Yearly < ::Montrose::Frequency
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/frequency/yearly.rb#6
  def include?(time); end

  # source://montrose//lib/montrose/frequency/yearly.rb#10
  def to_cron; end
end

# source://montrose//lib/montrose/hour.rb#2
class Montrose::Hour
  class << self
    # @raise [ConfigurationError]
    #
    # source://montrose//lib/montrose/hour.rb#15
    def assert(hour); end

    # source://montrose//lib/montrose/hour.rb#6
    def parse(arg); end
  end
end

# source://montrose//lib/montrose/hour.rb#3
Montrose::Hour::HOURS_IN_DAY = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/ical.rb#4
class Montrose::ICal
  # @return [ICal] a new instance of ICal
  #
  # source://montrose//lib/montrose/ical.rb#11
  def initialize(ical); end

  # source://montrose//lib/montrose/ical.rb#15
  def parse; end

  private

  # source://montrose//lib/montrose/ical.rb#25
  def extract_time_zone(ical_string); end

  # source://montrose//lib/montrose/ical.rb#65
  def parse_dtstart(tzid, time); end

  # source://montrose//lib/montrose/ical.rb#84
  def parse_exdate(exdate); end

  # source://montrose//lib/montrose/ical.rb#45
  def parse_properties(ical_string); end

  # source://montrose//lib/montrose/ical.rb#92
  def parse_rrule(rrule); end

  # source://montrose//lib/montrose/ical.rb#79
  def parse_time(time_string); end

  # source://montrose//lib/montrose/ical.rb#73
  def parse_timezone(time_string); end

  # First pass parsing to normalize arbitrary line breaks
  #
  # source://montrose//lib/montrose/ical.rb#33
  def property_lines(ical_string); end

  class << self
    # DTSTART;TZID=US-Eastern:19970902T090000
    # RRULE:FREQ=DAILY;INTERVAL=2
    #
    # source://montrose//lib/montrose/ical.rb#7
    def parse(ical); end
  end
end

# source://montrose//lib/montrose/minute.rb#2
class Montrose::Minute
  class << self
    # @raise [ConfigurationError]
    #
    # source://montrose//lib/montrose/minute.rb#15
    def assert(minute); end

    # source://montrose//lib/montrose/minute.rb#6
    def parse(arg); end
  end
end

# source://montrose//lib/montrose/minute.rb#3
Montrose::Minute::MINUTES_IN_HOUR = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/month.rb#2
class Montrose::Month
  extend ::Montrose::Utils

  class << self
    # source://montrose//lib/montrose/month.rb#22
    def names; end

    # source://montrose//lib/montrose/month.rb#30
    def number(name); end

    # source://montrose//lib/montrose/month.rb#40
    def number!(name); end

    # source://montrose//lib/montrose/month.rb#26
    def numbers; end

    # source://montrose//lib/montrose/month.rb#9
    def parse(value); end
  end
end

# starts with nil to match 1-12 numbering
#
# source://montrose//lib/montrose/month.rb#5
Montrose::Month::NAMES = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/month.rb#6
Montrose::Month::NUMBERS = T.let(T.unsafe(nil), Array)

# source://montrose//lib/montrose/month_day.rb#2
class Montrose::MonthDay
  class << self
    # @raise [ConfigurationError]
    #
    # source://montrose//lib/montrose/month_day.rb#17
    def assert(number); end

    # source://montrose//lib/montrose/month_day.rb#6
    def parse(mdays); end
  end
end

# source://montrose//lib/montrose/options.rb#4
class Montrose::Options
  include ::Montrose::Utils

  # @return [Options] a new instance of Options
  #
  # source://montrose//lib/montrose/options.rb#106
  def initialize(opts = T.unsafe(nil)); end

  # source://montrose//lib/montrose/options.rb#138
  def [](option); end

  # source://montrose//lib/montrose/options.rb#134
  def []=(option, val); end

  # source://montrose//lib/montrose/options.rb#24
  def at; end

  # source://montrose//lib/montrose/options.rb#233
  def at=(time); end

  # source://montrose//lib/montrose/options.rb#24
  def between; end

  # source://montrose//lib/montrose/options.rb#225
  def between=(range); end

  # source://montrose//lib/montrose/options.rb#24
  def covering; end

  # source://montrose//lib/montrose/options.rb#24
  def day; end

  # source://montrose//lib/montrose/options.rb#205
  def day=(days); end

  # source://montrose//lib/montrose/options.rb#24
  def during; end

  # source://montrose//lib/montrose/options.rb#191
  def during=(during_arg); end

  # source://montrose//lib/montrose/options.rb#24
  def every; end

  # source://montrose//lib/montrose/options.rb#164
  def every=(arg); end

  # source://montrose//lib/montrose/options.rb#24
  def except; end

  # source://montrose//lib/montrose/options.rb#245
  def except=(date); end

  # source://montrose//lib/montrose/options.rb#24
  def exclude_end; end

  # @raise [ArgumentError]
  #
  # source://montrose//lib/montrose/options.rb#149
  def fetch(key, *args); end

  # source://montrose//lib/montrose/options.rb#24
  def frequency; end

  # source://montrose//lib/montrose/options.rb#164
  def frequency=(arg); end

  # source://montrose//lib/montrose/options.rb#24
  def hour; end

  # source://montrose//lib/montrose/options.rb#187
  def hour=(hours); end

  # source://montrose//lib/montrose/options.rb#249
  def inspect; end

  # source://montrose//lib/montrose/options.rb#24
  def interval; end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/options.rb#160
  def key?(key); end

  # source://montrose//lib/montrose/options.rb#24
  def mday; end

  # source://montrose//lib/montrose/options.rb#209
  def mday=(mdays); end

  # source://montrose//lib/montrose/options.rb#142
  def merge(other); end

  # source://montrose//lib/montrose/options.rb#24
  def minute; end

  # source://montrose//lib/montrose/options.rb#183
  def minute=(minutes); end

  # source://montrose//lib/montrose/options.rb#24
  def month; end

  # source://montrose//lib/montrose/options.rb#221
  def month=(months); end

  # source://montrose//lib/montrose/options.rb#24
  def on; end

  # source://montrose//lib/montrose/options.rb#237
  def on=(arg); end

  # source://montrose//lib/montrose/options.rb#253
  def start_time; end

  # source://montrose//lib/montrose/options.rb#24
  def starts; end

  # source://montrose//lib/montrose/options.rb#175
  def starts=(time); end

  # source://montrose//lib/montrose/options.rb#126
  def to_h; end

  # source://montrose//lib/montrose/options.rb#126
  def to_hash; end

  # source://montrose//lib/montrose/options.rb#24
  def total; end

  # source://montrose//lib/montrose/options.rb#24
  def until; end

  # source://montrose//lib/montrose/options.rb#179
  def until=(time); end

  # source://montrose//lib/montrose/options.rb#24
  def week; end

  # source://montrose//lib/montrose/options.rb#217
  def week=(weeks); end

  # source://montrose//lib/montrose/options.rb#24
  def week_start; end

  # source://montrose//lib/montrose/options.rb#24
  def yday; end

  # source://montrose//lib/montrose/options.rb#213
  def yday=(ydays); end

  protected

  # source://montrose//lib/montrose/options.rb#24
  def covering=(_arg0); end

  # source://montrose//lib/montrose/options.rb#24
  def exclude_end=(_arg0); end

  # source://montrose//lib/montrose/options.rb#24
  def interval=(_arg0); end

  # source://montrose//lib/montrose/options.rb#24
  def total=(_arg0); end

  # source://montrose//lib/montrose/options.rb#24
  def week_start=(_arg0); end

  private

  # source://montrose//lib/montrose/options.rb#281
  def assert_hour(hour); end

  # @raise [ConfigurationError]
  #
  # source://montrose//lib/montrose/options.rb#309
  def assert_range_includes(range, item, absolute = T.unsafe(nil)); end

  # source://montrose//lib/montrose/options.rb#370
  def beginning_of_day; end

  # source://montrose//lib/montrose/options.rb#342
  def decompose_during_arg(during_arg); end

  # source://montrose//lib/montrose/options.rb#351
  def decompose_during_parts(during_parts); end

  # source://montrose//lib/montrose/options.rb#285
  def decompose_on_arg(arg); end

  # source://montrose//lib/montrose/options.rb#267
  def default_starts; end

  # source://montrose//lib/montrose/options.rb#271
  def default_until; end

  # source://montrose//lib/montrose/options.rb#338
  def duration_to_frequency_parts(duration); end

  # source://montrose//lib/montrose/options.rb#366
  def end_of_day; end

  # source://montrose//lib/montrose/options.rb#275
  def map_arg(arg, &block); end

  # @raise [ConfigurationError]
  #
  # source://montrose//lib/montrose/options.rb#299
  def month_or_day(key); end

  # source://montrose//lib/montrose/options.rb#328
  def numeric_to_frequency_parts(number); end

  # source://montrose//lib/montrose/options.rb#316
  def parse_frequency(input); end

  # source://montrose//lib/montrose/options.rb#362
  def time_of_day_parse(time_parts); end

  class << self
    # source://montrose//lib/montrose/options.rb#22
    def def_option(name); end

    # Returns the value of attribute default_every.
    #
    # source://montrose//lib/montrose/options.rb#28
    def default_every; end

    # Sets the attribute default_every
    #
    # @param value the value to set the attribute default_every to.
    #
    # source://montrose//lib/montrose/options.rb#28
    def default_every=(_arg0); end

    # source://montrose//lib/montrose/options.rb#77
    def default_options; end

    # Return the default starting time.
    #
    # @example Recurrence.default_starts #=> <Date>
    #
    # source://montrose//lib/montrose/options.rb#55
    def default_starts; end

    # Sets the attribute default_starts
    #
    # @param value the value to set the attribute default_starts to.
    #
    # source://montrose//lib/montrose/options.rb#29
    def default_starts=(_arg0); end

    # Return the default ending time.
    #
    # @example Recurrence.default_until #=> <Date>
    #
    # source://montrose//lib/montrose/options.rb#35
    def default_until; end

    # Sets the attribute default_until
    #
    # @param value the value to set the attribute default_until to.
    #
    # source://montrose//lib/montrose/options.rb#29
    def default_until=(_arg0); end

    # source://montrose//lib/montrose/options.rb#18
    def defined_options; end

    # private
    #
    # source://montrose//lib/montrose/options.rb#60
    def determine_default_starts; end

    # private
    #
    # source://montrose//lib/montrose/options.rb#40
    def determine_default_until; end

    # source://montrose//lib/montrose/options.rb#73
    def merge(opts = T.unsafe(nil)); end

    # source://montrose//lib/montrose/options.rb#12
    def new(options = T.unsafe(nil)); end
  end
end

# Represents the rules for a set of recurring events. Can be instantiated
# and extended in a variety of ways as show in the examples below.
#
# @attr_reader default_options [Montrose::Options] contains the recurrence rules in hash-like format
# @author Ross Kaffenberger
# @example daily for 10 occurrences
#   Montrose.daily(total: 10)
# @example daily until December 23, 2015
#   starts = Date.new(2015, 1, 1)
#   ends = Date.new(2015, 12, 23)
#   Montrose.daily(starts: starts, until: ends)
# @example every other day forever
#   Montrose.daily(interval: 2)
# @example every 10 days 5 occurrences
#   Montrose.every(10.days, total: 5)
# @example everyday in January for 3 years
#   starts = Time.current.beginning_of_year
#   ends = Time.current.end_of_year + 2.years
#   Montrose.daily(month: :january, between: starts...ends)
# @example weekly for 10 occurrences
#   Montrose.weekly(total: 10)
# @example weekly until December 23, 2015
#   ends_on = Date.new(2015, 12, 23)
#   starts_on = ends_on - 15.weeks
#   Montrose.every(:week, until: ends_on, starts: starts_on)
# @example every other week forever
#   Montrose.every(2.weeks)
# @example weekly on Tuesday and Thursday for five weeks from September 1, 2015 until October 5, 2015
#   Montrose.weekly(on: [:tuesday, :thursday],
#   between: Date.new(2015, 9, 1)..Date.new(2015, 10, 5))
# @example every other week on Mon, Wed and Fri until December 23 2015, but starting on Tuesday, September 1, 2015
#   Montrose.every(2.weeks,
#   on: [:monday, :wednesday, :friday],
#   starts: Date.new(2015, 9, 1))
# @example every other week on Tuesday and Thursday, for 8 occurrences
#   Montrose.weekly(on: [:tuesday, :thursday], total: 8, interval: 2)
# @example monthly on the first Friday for ten occurrences
#   Montrose.monthly(day: { friday: [1] }, total: 10)
# @example monthly on the first Friday until December 23, 2015
#   Montrose.every(:month, day: { friday: [1] }, until: Date.new(2016, 12, 23))
# @example every other month on the first and last Sunday of the month for 10 occurrences
#   Montrose.every(:month, day: { sunday: [1, -1] }, interval: 2, total: 10)
# @example monthly on the second-to-last Monday of the month for 6 months
#   Montrose.every(:month, day: { monday: [-2] }, total: 6)
# @example monthly on the third-to-the-last day of the month, forever
#   Montrose.every(:month, mday: [-3])
# @example monthly on the 2nd and 15th of the month for 10 occurrences
#   Montrose.every(:month, mday: [2, 15], total: 10)
# @example monthly on the first and last day of the month for 10 occurrences
#   Montrose.monthly(mday: [1, -1], total: 10)
# @example every 18 months on the 10th thru 15th of the month for 10 occurrences
#   Montrose.every(18.months, total: 10, mday: 10..15)
# @example every Tuesday, every other month
#   Montrose.every(2.months, on: :tuesday)
# @example yearly in June and July for 10 occurrences
#   Montrose.yearly(month: [:june, :july], total: 10)
# @example every other year on January, February, and March for 10 occurrences
#   Montrose.every(2.years, month: [:january, :february, :march], total: 10)
# @example every third year on the 1st, 100th and 200th day for 10 occurrences
#   Montrose.yearly(yday: [1, 100, 200], total: 10)
# @example every 20th Monday of the year, forever
#   Montrose.yearly(day: { monday: [20] })
# @example Monday of week number 20 forever
#   Montrose.yearly(week: [20], on: :monday)
# @example every Thursday in March, forever
#   Montrose.monthly(month: :march, on: :thursday, at: "12 pm")
# @example every Thursday, but only during June, July, and August, forever" do
#   Montrose.monthly(month: 6..8, on: :thursday)
# @example every Friday 13th, forever
#   Montrose.monthly(on: { friday: 13 })
# @example first Saturday that follows the first Sunday of the month, forever
#   Montrose.monthly(on: { saturday: 7..13 })
# @example every four years, the first Tuesday after a Monday in November, forever (U.S. Presidential Election day)
#   Montrose.every(4.years, month: :november, on: { tuesday: 2..8 })
# @example every 3 hours from 9:00 AM to 5:00 PM on a specific day
#   date = Date.new(2016, 9, 1)
#   Montrose.hourly(between: date..(date+1), hour: 9..17, interval: 3)
# @example every 15 minutes for 6 occurrences
#   Montrose.every(90.minutes, total: 6)
# @example every 20 minutes from 9:00 AM to 4:40 PM every day
#   Montrose.every(20.minutes, hour: 9..16)
# @example Minutely
#   Montrose.minutely
#   Montrose.r(every: :minute)
#   Montrose.every(10.minutes)
#   Montrose.r(every: 10.minutes)
#   Montrose.r(every: :minute, interval: 10) # every 10 minutes
#   Montrose.minutely(until: "9:00 PM")
#   Montrose.r(every: :minute, until: "9:00 PM")
# @example Daily
#   Montrose.daily
#   Montrose.every(:day)
#   Montrose.r(every: :day)
#   Montrose.every(9.days)
#   Montrose.r(every: 9.days)
#   Montrose.r(every: :day, interval: 9)
#   Montrose.daily(at: "9:00 AM")
#   Montrose.every(:day, at: "9:00 AM")
#   Montrose.r(every: :day, at: "9:00 AM")
#   Montrose.daily(total: 7)
#   Montrose.every(:day, total: 7)
#   Montrose.r(every: :day, total: 7)
# @example Weekly
#   Montrose.weekly
#   Montrose.every(:week)
#   Montrose.r(every: :week)
#   Montrose.every(:week, on: :monday)
#   Montrose.every(:week, on: [:monday, :wednesday, :friday])
#   Montrose.every(2.weeks, on: :friday)
#   Montrose.every(:week, on: :friday, at: "3:41 PM")
#   Montrose.weekly(on: :thursday)
# @example Monthly by month day
#   Montrose.monthly(mday: 1) # first of the month
#   Montrose.every(:month, mday: 1)
#   Montrose.r(every: :month, mday: 1)
#   Montrose.monthly(mday: [2, 15]) # 2nd and 15th of the month
#   Montrose.monthly(mday: -3) # third-to-last day of the month
#   Montrose.monthly(mday: 10..15) # 10th through the 15th day of the month
# @example Monthly by week day
#   Montrose.monthly(day: :friday, interval: 2) # every Friday every other month
#   Montrose.every(:month, day: :friday, interval: 2)
#   Montrose.r(every: :month, day: :friday, interval: 2)
#   Montrose.monthly(day: { friday: [1] }) # 1st Friday of the month
#   Montrose.monthly(day: { Sunday: [1, -1] }) # first and last Sunday of the month
#   Montrose.monthly(mday: 7..13, day: :saturday) # first Saturday that follow the first Sunday of the month
# @example Yearly
#   Montrose.yearly
#   Montrose.every(:year)
#   Montrose.r(every: :year)
#   Montrose.yearly(month: [:june, :july]) # yearly in June and July
#   Montrose.yearly(month: 6..8, day: :thursday) # yearly in June, July, August on Thursday
#   Montrose.yearly(yday: [1, 100]) # yearly on the 1st and 100th day of year
#   Montrose.yearly(on: { january: 31 })
#   Montrose.r(every: :year, on: { 10 => 31 }, interval: 3)
# @example Chaining
#   Montrose.weekly.starting(3.weeks.from_now).on(:friday)
#   Montrose.every(:day).at("4:05pm")
#   Montrose.yearly.between(Time.current..10.years.from_now)
# @example Enumerating events
#   r = Montrose.every(:month, mday: 31, until: "January 1, 2017")
#   r.each { |time| puts time.to_s }
#   r.take(10).to_a
# @example Merging rules
#   r.merge(starts: "2017-01-01").each { |time| puts time.to_s }
# @example Using #events Enumerator
#   r.events # => #<Enumerator: ...>
#   r.events.take(10).each { |date| puts date.to_s }
#   r.events.lazy.select { |time| time > 1.month.from_now }.take(3).each { |date| puts date.to_s }
# @example every hour and a half for four occurrences
#   Montrose.every(90.minutes, total: 4)
# @example a new recurrence
#   Montrose.r
#   Montrose.recurrence
#   Montrose::Recurrence.new
# @since 0.0.1
#
# source://montrose//lib/montrose/recurrence.rb#208
class Montrose::Recurrence
  include ::Montrose::Chainable
  include ::Enumerable
  extend ::Forwardable

  # @return [Recurrence] a new instance of Recurrence
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#261
  def initialize(opts = T.unsafe(nil)); end

  # Returns json of options used to create the recurrence
  #
  # @return [Hash] json of recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#331
  def as_json(*args); end

  # contains the recurrence rules in hash-like format
  #
  # @return [Montrose::Options] the current value of default_options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#213
  def default_options; end

  # Iterate over the events of a recurrence. Along with the Enumerable
  # module, this makes Montrose occurrences enumerable like other Ruby
  # collections
  #
  # @example Iterate over a finite recurrence
  #   recurrence = Montrose.recurrence(every: :day, until: 1.year.from_now)
  #   recurrence.each do |event|
  #   puts event
  #   end
  # @example Iterate over an infinite recurrence
  #   recurrence = Montrose.recurrence(every: :day)
  #   recurrence.lazy.each do |event|
  #   puts event
  #   end
  # @return [Enumerator] an enumerator of recurrence timestamps
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#306
  def each(&block); end

  # Return true/false if given timestamp occurs before
  # the recurrence
  #
  # @return [Boolean] whether or not timestamp is earlier
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#397
  def earlier?(timestamp); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def ends_at(*args, **_arg1, &block); end

  # Returns an enumerator for iterating over timestamps in the recurrence
  #
  # @example Return the events
  #   recurrence = Montrose.recurrence(every: :day)
  #   recurrence.events
  # @example Iterate over a finite recurrence
  #   recurrence = Montrose.recurrence(every: :day, until: 1.year.from_now)
  #   recurrence.events.each do |event|
  #   puts event
  #   end
  # @example Iterate over an infinite recurrence
  #   recurrence = Montrose.recurrence(every: :day)
  #   recurrence.events.lazy.each do |event|
  #   puts event
  #   end
  # @return [Enumerator] an enumerator of recurrence timestamps
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#285
  def events; end

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#363
  def fast_forward(timestamp); end

  # Return true/false if recurrence will terminate
  #
  # @return [Boolean] returns true if recurrence has an end
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#380
  def finite?; end

  # Return true/false if given timestamp equals a timestamp given
  # by the recurrence
  #
  # @return [Boolean] whether or not timestamp is included in recurrence
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#352
  def include?(timestamp); end

  # Return true/false if recurrence will iterate infinitely
  #
  # @return [Boolean] returns true if recurrence has no end
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#388
  def infinite?; end

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#343
  def inspect; end

  # Return true/false if given timestamp occurs after
  # the recurrence
  #
  # @return [Boolean] whether or not timestamp is later
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#406
  def later?(timestamp); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def starts_at(*args, **_arg1, &block); end

  # Returns a hash of the options used to create the recurrence
  #
  # @return [Hash] hash of recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#314
  def to_h; end

  # Returns a hash of the options used to create the recurrence
  #
  # @return [Hash] hash of recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#314
  def to_hash; end

  # Returns json string of options used to create the recurrence
  #
  # @return [String] json of recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#323
  def to_json(*args); end

  # Returns options used to create the recurrence in YAML format
  #
  # @return [String] YAML-formatted recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#339
  def to_yaml(*args); end

  private

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/recurrence.rb#412
  def event_enum; end

  class << self
    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#225
    def dump(obj); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#256
    def from_ical(ical); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#242
    def from_json(json); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#252
    def from_yaml(yaml); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#242
    def load(json); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/recurrence.rb#219
    def new(options = T.unsafe(nil)); end
  end
end

# source://montrose//lib/montrose/refinements/array_concat.rb#4
module Montrose::Refinements; end

# source://montrose//lib/montrose/refinements/array_concat.rb#5
module Montrose::Refinements::ArrayConcat; end

# Defines the Rule duck type for recurrence rules
#
# source://montrose//lib/montrose/rule.rb#5
module Montrose::Rule
  mixes_in_class_methods ::Montrose::Rule::ClassMethods

  # source://montrose//lib/montrose/rule.rb#32
  def advance!(_time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule.rb#36
  def continue?(_time = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule.rb#28
  def include?(_time); end

  class << self
    # @private
    #
    # source://montrose//lib/montrose/rule.rb#24
    def included(base); end
  end
end

# source://montrose//lib/montrose/rule/after.rb#5
class Montrose::Rule::After
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param start_time [Time] - lower bound timestamp
  # @return [After] a new instance of After
  #
  # source://montrose//lib/montrose/rule/after.rb#16
  def initialize(start_time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/after.rb#24
  def continue?(_time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/after.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/after.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule.rb#40
module Montrose::Rule::ClassMethods
  # source://montrose//lib/montrose/rule.rb#41
  def apply_option(_opts); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule.rb#45
  def apply_options?(opts); end

  # source://montrose//lib/montrose/rule.rb#49
  def from_options(opts); end
end

# source://montrose//lib/montrose/rule/covering.rb#5
class Montrose::Rule::Covering
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param covering [Range] - timestamp range
  # @return [Covering] a new instance of Covering
  #
  # source://montrose//lib/montrose/rule/covering.rb#16
  def initialize(covering); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/covering.rb#29
  def continue?(time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/covering.rb#25
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/covering.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/covering.rb#33
class Montrose::Rule::Covering::DateRange < ::SimpleDelegator
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/covering.rb#34
  def include?(time); end
end

# source://montrose//lib/montrose/rule/day_of_month.rb#5
class Montrose::Rule::DayOfMonth
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param days [Array<Fixnum>] - valid days of month, i.e. [1, 2, -1]
  # @return [DayOfMonth] a new instance of DayOfMonth
  #
  # source://montrose//lib/montrose/rule/day_of_month.rb#16
  def initialize(days); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/day_of_month.rb#20
  def include?(time); end

  private

  # matches days specified at negative numbers
  #
  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/day_of_month.rb#27
  def included_from_end_of_month?(time); end

  class << self
    # source://montrose//lib/montrose/rule/day_of_month.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/day_of_week.rb#5
class Montrose::Rule::DayOfWeek
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param days [Array<Fixnum>] - valid days of week, e.g. [1, 2, 7]
  # @return [DayOfWeek] a new instance of DayOfWeek
  #
  # source://montrose//lib/montrose/rule/day_of_week.rb#16
  def initialize(days); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/day_of_week.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/day_of_week.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/day_of_year.rb#5
class Montrose::Rule::DayOfYear
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param days [Array<Fixnum>] - valid days of year, e.g. [1, 2, -1]
  # @return [DayOfYear] a new instance of DayOfYear
  #
  # source://montrose//lib/montrose/rule/day_of_year.rb#16
  def initialize(days); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/day_of_year.rb#20
  def include?(time); end

  private

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/day_of_year.rb#26
  def included_from_end_of_month?(time); end

  class << self
    # source://montrose//lib/montrose/rule/day_of_year.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/during.rb#5
class Montrose::Rule::During
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param during [Array<Array<Fixnum>>] array of time parts arrays, e.g. [[9, 0, 0], [17, 0, 0]], i.e., "9 to 5"
  # @return [During] a new instance of During
  #
  # source://montrose//lib/montrose/rule/during.rb#16
  def initialize(during); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/during.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/during.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/during.rb#24
class Montrose::Rule::During::TimeOfDayRange
  # @return [TimeOfDayRange] a new instance of TimeOfDayRange
  #
  # source://montrose//lib/montrose/rule/during.rb#25
  def initialize(first, last, exclude_end: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/during.rb#31
  def include?(time); end

  private

  # source://montrose//lib/montrose/rule/during.rb#37
  def range; end
end

# source://montrose//lib/montrose/rule/except.rb#5
class Montrose::Rule::Except
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param dates [Date] - array of date objects
  # @return [Except] a new instance of Except
  #
  # source://montrose//lib/montrose/rule/except.rb#16
  def initialize(dates); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/except.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/except.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/hour_of_day.rb#5
class Montrose::Rule::HourOfDay
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param hours [Array<Fixnum>] valid hours of days, e.g. [1, 2, 24]
  # @return [HourOfDay] a new instance of HourOfDay
  #
  # source://montrose//lib/montrose/rule/hour_of_day.rb#16
  def initialize(hours); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/hour_of_day.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/hour_of_day.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/minute_of_hour.rb#5
class Montrose::Rule::MinuteOfHour
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param minutes [Array<Fixnum>] valid minutes of hour, e.g. [0, 20, 59]
  # @return [MinuteOfHour] a new instance of MinuteOfHour
  #
  # source://montrose//lib/montrose/rule/minute_of_hour.rb#16
  def initialize(minutes); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/minute_of_hour.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/minute_of_hour.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/month_of_year.rb#5
class Montrose::Rule::MonthOfYear
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param months [Array] - valid month numbers
  # @return [MonthOfYear] a new instance of MonthOfYear
  #
  # source://montrose//lib/montrose/rule/month_of_year.rb#16
  def initialize(months); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/month_of_year.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/month_of_year.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/nth_day_matcher.rb#7
class Montrose::Rule::NthDayMatcher
  extend ::Forwardable

  # @return [NthDayMatcher] a new instance of NthDayMatcher
  #
  # source://montrose//lib/montrose/rule/nth_day_matcher.rb#12
  def initialize(wday, period_day); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def first_wday(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/nth_day_matcher.rb#17
  def matches?(nth_occ); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def nth_day(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def total_days(*args, **_arg1, &block); end

  private

  # source://montrose//lib/montrose/rule/nth_day_matcher.rb#23
  def current_occ; end

  # source://montrose//lib/montrose/rule/nth_day_matcher.rb#31
  def first_occ; end

  # source://montrose//lib/montrose/rule/nth_day_matcher.rb#27
  def total_occ; end
end

# source://montrose//lib/montrose/rule/nth_day_of_month.rb#5
class Montrose::Rule::NthDayOfMonth
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param days [Hash] - valid days of week to month occurrence pairs
  # @return [NthDayOfMonth] a new instance of NthDayOfMonth
  #
  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#20
  def initialize(days); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#24
  def include?(time); end

  private

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#30
  def nth_day?(time); end

  class << self
    # source://montrose//lib/montrose/rule/nth_day_of_month.rb#12
    def apply_options(opts); end

    # @return [Boolean]
    #
    # source://montrose//lib/montrose/rule/nth_day_of_month.rb#8
    def apply_options?(opts); end
  end
end

# source://montrose//lib/montrose/rule/nth_day_of_month.rb#36
class Montrose::Rule::NthDayOfMonth::MonthDay
  # @return [MonthDay] a new instance of MonthDay
  #
  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#37
  def initialize(time); end

  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#45
  def first_wday; end

  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#41
  def nth_day; end

  # source://montrose//lib/montrose/rule/nth_day_of_month.rb#49
  def total_days; end
end

# source://montrose//lib/montrose/rule/nth_day_of_year.rb#5
class Montrose::Rule::NthDayOfYear
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param days [Hash] - valid days of week to year occurrence pairs
  # @return [NthDayOfYear] a new instance of NthDayOfYear
  #
  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#20
  def initialize(days); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#24
  def include?(time); end

  private

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#30
  def nth_day?(time); end

  class << self
    # source://montrose//lib/montrose/rule/nth_day_of_year.rb#12
    def apply_options(opts); end

    # @return [Boolean]
    #
    # source://montrose//lib/montrose/rule/nth_day_of_year.rb#8
    def apply_options?(opts); end
  end
end

# source://montrose//lib/montrose/rule/nth_day_of_year.rb#36
class Montrose::Rule::NthDayOfYear::YearDay
  # @return [YearDay] a new instance of YearDay
  #
  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#37
  def initialize(time); end

  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#45
  def first_wday; end

  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#41
  def nth_day; end

  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#49
  def total_days; end

  private

  # Get the days in the month for +time
  #
  # source://montrose//lib/montrose/rule/nth_day_of_year.rb#56
  def days_in_year(time); end
end

# source://montrose//lib/montrose/rule/time_of_day.rb#5
class Montrose::Rule::TimeOfDay
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param times [Array<Time>] - valid times
  # @return [TimeOfDay] a new instance of TimeOfDay
  #
  # source://montrose//lib/montrose/rule/time_of_day.rb#16
  def initialize(times); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/time_of_day.rb#20
  def include?(time); end

  private

  # source://montrose//lib/montrose/rule/time_of_day.rb#26
  def parts(time); end

  class << self
    # source://montrose//lib/montrose/rule/time_of_day.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/total.rb#5
class Montrose::Rule::Total
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # @return [Total] a new instance of Total
  #
  # source://montrose//lib/montrose/rule/total.rb#12
  def initialize(max); end

  # source://montrose//lib/montrose/rule/total.rb#21
  def advance!(time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/total.rb#26
  def continue?(_time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/total.rb#17
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/total.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/until.rb#5
class Montrose::Rule::Until
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # @return [Until] a new instance of Until
  #
  # source://montrose//lib/montrose/rule/until.rb#14
  def initialize(opts); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/until.rb#27
  def continue?(_time); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/until.rb#19
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/until.rb#8
    def apply_options(opts); end
  end
end

# source://montrose//lib/montrose/rule/week_of_year.rb#5
class Montrose::Rule::WeekOfYear
  include ::Montrose::Rule
  extend ::Montrose::Rule::ClassMethods

  # Initializes rule
  #
  # @param weeks [Array[Fixnum]] - valid weeks of year
  # @return [WeekOfYear] a new instance of WeekOfYear
  #
  # source://montrose//lib/montrose/rule/week_of_year.rb#16
  def initialize(weeks); end

  # @return [Boolean]
  #
  # source://montrose//lib/montrose/rule/week_of_year.rb#20
  def include?(time); end

  class << self
    # source://montrose//lib/montrose/rule/week_of_year.rb#8
    def apply_options(opts); end
  end
end

# A schedule represents a group of recurrences
#
# @attr_reader rules [Array] the list of recurrences
# @author Ross Kaffenberger
# @since 0.0.1
#
# source://montrose//lib/montrose/schedule.rb#10
class Montrose::Schedule
  include ::Enumerable

  # @return [Schedule] a new instance of Schedule
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#59
  def initialize(rules = T.unsafe(nil)); end

  # Add a recurrence rule to the schedule, either by hash or recurrence
  # instance
  #
  # @example Add a recurrence by hash
  #   schedule = Montrose::Schedule.new
  #   schedule << { every: :day }
  # @example Add a recurrence by instance
  #   schedule = Montrose::Schedule.new
  #   recurrence = Montrose.recurrence(every: :day)
  #   schedule << recurrence
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#75
  def <<(rule); end

  # Add a recurrence rule to the schedule, either by hash or recurrence
  # instance
  #
  # @example Add a recurrence by hash
  #   schedule = Montrose::Schedule.new
  #   schedule << { every: :day }
  # @example Add a recurrence by instance
  #   schedule = Montrose::Schedule.new
  #   recurrence = Montrose.recurrence(every: :day)
  #   schedule << recurrence
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#75
  def add(rule); end

  # Returns json array of options used to create the schedule
  #
  # @return [Array] json of schedule recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#156
  def as_json(*args); end

  # Iterate over the events of a recurrence. Along with the Enumerable
  # module, this makes Montrose occurrences enumerable like other Ruby
  # collections
  #
  # @example Iterate over a finite recurrence
  #   schedule = Montrose::Schedule.build do |s|
  #   s << { every: :day }
  #   end
  #   schedule.each do |event|
  #   puts event
  #   end
  # @example Iterate over an infinite recurrence
  #   schedule = Montrose::Schedule.build do |s|
  #   s << { every: :day }
  #   end
  #   schedule.lazy.each do |event|
  #   puts event
  #   end
  # @return [Enumerator] an enumerator of recurrence timestamps
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#112
  def each(&block); end

  # Returns an enumerator for iterating over timestamps in the schedule
  #
  # @example Return the events
  #   schedule = Montrose::Schedule.build do |s|
  #   s << { every: :day }
  #   end
  #   schedule.events
  # @return [Enumerator] an enumerator of recurrence timestamps
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#126
  def events(opts = T.unsafe(nil)); end

  # Return true/false if given timestamp is included in any of the rules
  # found in the schedule
  #
  # @return [Boolean] whether or not timestamp is included in schedule
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#87
  def include?(timestamp); end

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#168
  def inspect; end

  # the list of recurrences
  #
  # @return [Array] the current value of rules
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#13
  def rules; end

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#13
  def rules=(_arg0); end

  # Returns an array of the options used to create the recurrence
  #
  # @return [Array] array of hashes of recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#140
  def to_a; end

  # Returns json string of options used to create the schedule
  #
  # @return [String] json of schedule recurrences
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#148
  def to_json(*args); end

  # Returns options used to create the schedule recurrences in YAML format
  #
  # @return [String] YAML-formatted schedule recurrence options
  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#164
  def to_yaml(*args); end

  private

  # @since 0.0.1
  #
  # source://montrose//lib/montrose/schedule.rb#174
  def active_enums(enums); end

  class << self
    # Instantiates a schedule and yields the instance to an optional
    # block for building recurrences inline
    #
    # @example Build a schedule with multiple rules added in the given block
    #   schedule = Montrose::Schedule.build do |s|
    #   s << { every: :day }
    #   s << { every: :year }
    #   end
    # @return [Montrose::Schedule]
    # @since 0.0.1
    # @yield [schedule]
    #
    # source://montrose//lib/montrose/schedule.rb#27
    def build; end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/schedule.rb#33
    def dump(obj); end

    # @since 0.0.1
    #
    # source://montrose//lib/montrose/schedule.rb#50
    def load(json); end
  end
end

# source://montrose//lib/montrose/errors.rb#6
class Montrose::SerializationError < ::Montrose::Error; end

# Maintains stack of recurrences rules that apply to
# an associated recurrence; manages advancing state
# on each rule in stack as time instances are iterated.
#
# source://montrose//lib/montrose/stack.rb#8
class Montrose::Stack
  # @return [Stack] a new instance of Stack
  #
  # source://montrose//lib/montrose/stack.rb#31
  def initialize(opts = T.unsafe(nil)); end

  # Given a time instance, advances state of when all
  # recurrence rules on the stack match, and yielding
  # time to the block, otherwise, invokes break? on
  # non-matching rules.
  #
  # @param time [Time] - time instance candidate for recurrence
  #
  # source://montrose//lib/montrose/stack.rb#42
  def advance(time); end

  class << self
    # source://montrose//lib/montrose/stack.rb#9
    def build(opts = T.unsafe(nil)); end
  end
end

# source://montrose//lib/montrose/time_of_day.rb#2
class Montrose::TimeOfDay
  include ::Comparable

  # @return [TimeOfDay] a new instance of TimeOfDay
  #
  # source://montrose//lib/montrose/time_of_day.rb#21
  def initialize(parts); end

  # def inspect
  #   "#<Montrose::TimeOfDay #{format_time(@hour)}:#{format_time(@min)}:#{format_time(@sec)}"
  # end
  #
  # source://montrose//lib/montrose/time_of_day.rb#38
  def <=>(other); end

  # Returns the value of attribute hour.
  #
  # source://montrose//lib/montrose/time_of_day.rb#5
  def hour; end

  # Returns the value of attribute min.
  #
  # source://montrose//lib/montrose/time_of_day.rb#5
  def min; end

  # Returns the value of attribute parts.
  #
  # source://montrose//lib/montrose/time_of_day.rb#5
  def parts; end

  # Returns the value of attribute sec.
  #
  # source://montrose//lib/montrose/time_of_day.rb#5
  def sec; end

  # source://montrose//lib/montrose/time_of_day.rb#26
  def seconds_since_midnight; end

  # source://montrose//lib/montrose/time_of_day.rb#30
  def to_a; end

  private

  # source://montrose//lib/montrose/time_of_day.rb#44
  def format_time(part); end

  class << self
    # source://montrose//lib/montrose/time_of_day.rb#13
    def from_time(time); end

    # source://montrose//lib/montrose/time_of_day.rb#7
    def parse(arg); end

    # source://montrose//lib/montrose/time_of_day.rb#17
    def to_parts(time); end
  end
end

# source://montrose//lib/montrose/utils.rb#4
module Montrose::Utils
  private

  # source://montrose//lib/montrose/utils.rb#31
  def as_date(time); end

  # source://montrose//lib/montrose/utils.rb#12
  def as_time(time); end

  # source://montrose//lib/montrose/utils.rb#39
  def current_time; end

  # source://montrose//lib/montrose/utils.rb#43
  def days_in_month(month, year = T.unsafe(nil)); end

  # Returns the number of days in the given year.
  # If no year is specified, it will use the current year.
  # https://github.com/rails/rails/pull/22244
  #
  # source://montrose//lib/montrose/utils.rb#51
  def days_in_year(year); end

  # Recurrence at fractions of a second are not recognized
  #
  # source://montrose//lib/montrose/utils.rb#27
  def normalize_time(time); end

  # source://montrose//lib/montrose/utils.rb#35
  def parse_time(*args); end

  # Returns string.to_i only if string fully matches an integer
  # otherwise ensures that return value won't match a valid index
  #
  # source://montrose//lib/montrose/utils.rb#57
  def to_index(string); end

  class << self
    # source://montrose//lib/montrose/utils.rb#31
    def as_date(time); end

    # source://montrose//lib/montrose/utils.rb#12
    def as_time(time); end

    # source://montrose//lib/montrose/utils.rb#39
    def current_time; end

    # source://montrose//lib/montrose/utils.rb#43
    def days_in_month(month, year = T.unsafe(nil)); end

    # Returns the number of days in the given year.
    # If no year is specified, it will use the current year.
    # https://github.com/rails/rails/pull/22244
    #
    # source://montrose//lib/montrose/utils.rb#51
    def days_in_year(year); end

    # Recurrence at fractions of a second are not recognized
    #
    # source://montrose//lib/montrose/utils.rb#27
    def normalize_time(time); end

    # source://montrose//lib/montrose/utils.rb#35
    def parse_time(*args); end

    # Returns string.to_i only if string fully matches an integer
    # otherwise ensures that return value won't match a valid index
    #
    # source://montrose//lib/montrose/utils.rb#57
    def to_index(string); end
  end
end

# source://montrose//lib/montrose/utils.rb#10
Montrose::Utils::MAX_DAYS_IN_MONTH = T.let(T.unsafe(nil), Integer)

# source://montrose//lib/montrose/utils.rb#8
Montrose::Utils::MAX_DAYS_IN_YEAR = T.let(T.unsafe(nil), Integer)

# source://montrose//lib/montrose/utils.rb#7
Montrose::Utils::MAX_HOURS_IN_DAY = T.let(T.unsafe(nil), Integer)

# source://montrose//lib/montrose/utils.rb#9
Montrose::Utils::MAX_WEEKS_IN_YEAR = T.let(T.unsafe(nil), Integer)

# source://montrose//lib/montrose/version.rb#4
Montrose::VERSION = T.let(T.unsafe(nil), String)

# source://montrose//lib/montrose/week.rb#2
class Montrose::Week
  class << self
    # @raise [ConfigurationError]
    #
    # source://montrose//lib/montrose/week.rb#12
    def assert(number); end

    # source://montrose//lib/montrose/week.rb#6
    def parse(arg); end
  end
end

# source://montrose//lib/montrose/year_day.rb#2
class Montrose::YearDay
  class << self
    # @raise [ConfigurationError]
    #
    # source://montrose//lib/montrose/year_day.rb#17
    def assert(number); end

    # source://montrose//lib/montrose/year_day.rb#6
    def parse(ydays); end
  end
end
