# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `with_advisory_lock` gem.
# Please instead update this file by running `bin/tapioca gem with_advisory_lock`.

class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  include ::WithAdvisoryLock::Concern
  extend ::WithAdvisoryLock::Concern::ClassMethods
end

# source://with_advisory_lock//lib/with_advisory_lock/version.rb#1
module WithAdvisoryLock
  extend ::ActiveSupport::Autoload
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#21
class WithAdvisoryLock::Base
  # @return [Base] a new instance of Base
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def initialize(connection, lock_name, options); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#49
  def already_locked?; end

  # Returns the value of attribute connection.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#22
  def connection; end

  # Returns the value of attribute lock_name.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#22
  def lock_name; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#47
  def lock_stack(*_arg0, **_arg1, &_arg2); end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#39
  def lock_stack_item; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#35
  def lock_str; end

  # Returns the value of attribute shared.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#22
  def shared; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#63
  def stable_hashcode(input); end

  # Returns the value of attribute timeout_seconds.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#22
  def timeout_seconds; end

  # Returns the value of attribute transaction.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#22
  def transaction; end

  # Prevent AR from caching results improperly
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#100
  def unique_column_name; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#53
  def with_advisory_lock_if_needed(&block); end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#84
  def yield_with_lock; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#73
  def yield_with_lock_and_timeout(&block); end

  class << self
    # source://with_advisory_lock//lib/with_advisory_lock/base.rb#43
    def lock_stack; end
  end
end

# source://with_advisory_lock//lib/with_advisory_lock/concern.rb#4
module WithAdvisoryLock::Concern
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::WithAdvisoryLock::Concern::ClassMethods

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#6
  def advisory_lock_exists?(*_arg0, **_arg1, &_arg2); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#6
  def with_advisory_lock(*_arg0, **_arg1, &_arg2); end
end

# source://with_advisory_lock//lib/with_advisory_lock/concern.rb#8
module WithAdvisoryLock::Concern::ClassMethods
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#20
  def advisory_lock_exists?(lock_name); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#25
  def current_advisory_lock; end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#9
  def with_advisory_lock(lock_name, options = T.unsafe(nil), &block); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#14
  def with_advisory_lock_result(lock_name, options = T.unsafe(nil), &block); end

  private

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#32
  def impl_class(options = T.unsafe(nil)); end
end

# source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#2
class WithAdvisoryLock::DatabaseAdapterSupport
  # @return [DatabaseAdapterSupport] a new instance of DatabaseAdapterSupport
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#7
  def initialize(connection); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#12
  def mysql?; end

  # Nested lock support for MySQL was introduced in 5.7.5
  # Checking by version number is complicated by MySQL compatible DBs (like MariaDB) having their own versioning schemes
  # Therefore, we check for nested lock support by simply trying a nested lock, then testing and caching the outcome
  #
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#19
  def mysql_nested_lock_support?; end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#55
  def postgresql?; end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#59
  def sqlite?; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#17
WithAdvisoryLock::FAILED_TO_LOCK = T.let(T.unsafe(nil), WithAdvisoryLock::Result)

# source://with_advisory_lock//lib/with_advisory_lock/flock.rb#4
class WithAdvisoryLock::Flock < ::WithAdvisoryLock::Base
  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#14
  def file_io; end

  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#5
  def filename; end

  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#28
  def release_lock; end

  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#21
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#19
class WithAdvisoryLock::LockStackItem < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute shared
  #
  # @return [Object] the current value of shared
  def shared; end

  # Sets the attribute shared
  #
  # @param value [Object] the value to set the attribute shared to.
  # @return [Object] the newly set value
  def shared=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# MySQL > 5.7.5 supports nested locks
#
# source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#4
class WithAdvisoryLock::MySQL < ::WithAdvisoryLock::Base
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#17
  def execute_successful?(mysql_function); end

  # MySQL wants a string as the lock key.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#23
  def quoted_lock_str; end

  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#13
  def release_lock; end

  # See https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_get-lock
  #
  # @raise [ArgumentError]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#5
  def try_lock; end
end

# For MySQL < 5.7.5 that does not support nested locks
#
# source://with_advisory_lock//lib/with_advisory_lock/mysql_no_nesting.rb#4
class WithAdvisoryLock::MySQLNoNesting < ::WithAdvisoryLock::MySQL
  # MySQL doesn't support nested locks:
  #
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql_no_nesting.rb#16
  def already_locked?; end

  # See http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_get-lock
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql_no_nesting.rb#5
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/nested_advisory_lock_error.rb#2
class WithAdvisoryLock::NestedAdvisoryLockError < ::StandardError
  # @return [NestedAdvisoryLockError] a new instance of NestedAdvisoryLockError
  #
  # source://with_advisory_lock//lib/with_advisory_lock/nested_advisory_lock_error.rb#5
  def initialize(msg = T.unsafe(nil), lock_stack = T.unsafe(nil)); end

  # Returns the value of attribute lock_stack.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/nested_advisory_lock_error.rb#3
  def lock_stack; end

  # Sets the attribute lock_stack
  #
  # @param value the value to set the attribute lock_stack to.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/nested_advisory_lock_error.rb#3
  def lock_stack=(_arg0); end

  # source://with_advisory_lock//lib/with_advisory_lock/nested_advisory_lock_error.rb#10
  def to_s; end
end

# source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#3
class WithAdvisoryLock::PostgreSQL < ::WithAdvisoryLock::Base
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#23
  def execute_successful?(pg_function); end

  # PostgreSQL wants 2 32bit integers as the lock key.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#32
  def lock_keys; end

  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#9
  def release_lock; end

  # See http://www.postgresql.org/docs/9.1/static/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#4
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#4
class WithAdvisoryLock::Result
  # @return [Result] a new instance of Result
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#7
  def initialize(lock_was_acquired, result = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#12
  def lock_was_acquired?; end

  # Returns the value of attribute result.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#5
  def result; end
end

# source://with_advisory_lock//lib/with_advisory_lock/version.rb#2
WithAdvisoryLock::VERSION = T.let(T.unsafe(nil), Gem::Version)
