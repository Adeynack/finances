# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rufus-scheduler` gem.
# Please instead update this file by running `bin/tapioca gem rufus-scheduler`.

# source://rufus-scheduler//lib/rufus/scheduler.rb#8
module Rufus; end

# source://rufus-scheduler//lib/rufus/scheduler.rb#10
class Rufus::Scheduler
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#58
  def initialize(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#128
  def around_trigger(job); end

  # --
  # scheduling methods
  # ++
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#184
  def at(time, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#295
  def at_jobs(opts = T.unsafe(nil)); end

  # Callback called when a job is triggered. If the lock cannot be acquired,
  # the job won't run (though it'll still be scheduled to run again if
  # necessary).
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#363
  def confirm_lock; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#224
  def cron(cronline, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#315
  def cron_jobs(opts = T.unsafe(nil)); end

  # Returns the value of attribute discard_past.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#43
  def discard_past; end

  # Sets the attribute discard_past
  #
  # @param value the value to set the attribute discard_past to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#43
  def discard_past=(_arg0); end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#152
  def down?; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#204
  def every(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#305
  def every_jobs(opts = T.unsafe(nil)); end

  # Returns the value of attribute frequency.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#42
  def frequency; end

  # Sets the attribute frequency
  #
  # @param value the value to set the attribute frequency to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#42
  def frequency=(_arg0); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#194
  def in(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#300
  def in_jobs(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#214
  def interval(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#310
  def interval_jobs(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#320
  def job(job_id); end

  # Returns all the scheduled jobs
  # (even those right before re-schedule).
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#277
  def jobs(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#138
  def join(time_limit = T.unsafe(nil)); end

  # Returns true if the scheduler has acquired the [exclusive] lock and
  # thus may run.
  #
  # Most of the time, a scheduler is run alone and this method should
  # return true. It is useful in cases where among a group of applications
  # only one of them should run the scheduler. For schedulers that should
  # not run, the method should return false.
  #
  # Out of the box, rufus-scheduler proposes the
  # :lockfile => 'path/to/lock/file' scheduler start option. It makes
  # it easy for schedulers on the same machine to determine which should
  # run (the first to write the lockfile and lock it). It uses "man 2 flock"
  # so it probably won't work reliably on distributed file systems.
  #
  # If one needs to use a special/different locking mechanism, the scheduler
  # accepts :scheduler_lock => lock_object. lock_object only needs to respond
  # to #lock
  # and #unlock, and both of these methods should be idempotent.
  #
  # Look at rufus/scheduler/locks.rb for an example.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#346
  def lock; end

  # attr_accessor :min_work_threads
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#52
  def max_work_threads; end

  # attr_accessor :min_work_threads
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#52
  def max_work_threads=(_arg0); end

  # Returns the value of attribute mutexes.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#49
  def mutexes; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#416
  def occurrences(time0, time1, format = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#439
  def on_error(job, err); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#167
  def pause; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#162
  def paused?; end

  # Returns the value of attribute paused_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#46
  def paused_at; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#248
  def repeat(arg, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#172
  def resume(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#411
  def running_jobs(opts = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#234
  def schedule(arg, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#189
  def schedule_at(time, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#229
  def schedule_cron(cronline, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#209
  def schedule_every(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#199
  def schedule_in(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#219
  def schedule_interval(duration, callable = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # Returns true if this job is currently scheduled.
  #
  # Takes extra care to answer true if the job is a repeat job
  # currently firing.
  #
  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#373
  def scheduled?(job_or_job_id); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#514
  def shutdown(opt = T.unsafe(nil)); end

  # Returns the value of attribute started_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#45
  def started_at; end

  # Returns the value of attribute stderr.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#54
  def stderr; end

  # Sets the attribute stderr
  #
  # @param value the value to set the attribute stderr to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#54
  def stderr=(_arg0); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#514
  def stop(opt = T.unsafe(nil)); end

  # Returns the value of attribute thread.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#47
  def thread; end

  # Returns the value of attribute thread_key.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#48
  def thread_key; end

  # Lists all the threads associated with this scheduler.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#382
  def threads; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#434
  def timeline(time0, time1); end

  # Sister method to #lock, is called when the scheduler shuts down.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#353
  def unlock; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#261
  def unschedule(job_or_job_id); end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#157
  def up?; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#123
  def uptime; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#133
  def uptime_s; end

  # Returns the value of attribute work_queue.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#56
  def work_queue; end

  # Lists all the work threads (the ones actually running the scheduled
  # block code)
  #
  # Accepts a query option, which can be set to:
  # * :all (default), returns all the threads that are work threads
  #   or are currently running a job
  # * :active, returns all threads that are currently running a job
  # * :vacant, returns the threads that are not running a job
  #
  # If, thanks to :blocking => true, a job is scheduled to monopolize the
  # main scheduler thread, that thread will get returned when :active or
  # :all.
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#400
  def work_threads(query = T.unsafe(nil)); end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler.rb#700
  def do_schedule(job_type, t, callable, opts, return_job_instance, block); end

  # Returns [ job, job_id ]
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#608
  def fetch(job_or_job_id); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#543
  def join_shutdown(opts); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#567
  def kill_shutdown(opts); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#733
  def ltstamp; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#732
  def monow; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#601
  def no_time_limit_join; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#573
  def regular_shutdown(opts); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#695
  def rejoin; end

  # def free_all_work_threads
  #
  #  work_threads.each { |t| t.raise(KillSignal) }
  # end
  #
  # source://rufus-scheduler//lib/rufus/scheduler.rb#629
  def start; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#617
  def terminate_all_jobs; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#578
  def time_limit_join(limit); end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#676
  def timeout_jobs; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#666
  def trigger_jobs; end

  # source://rufus-scheduler//lib/rufus/scheduler.rb#661
  def unschedule_jobs; end

  class << self
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#187
    def h_to_s(t = T.unsafe(nil)); end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#206
    def ltstamp; end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#201
    def monow; end

    # --
    # time and string methods
    # ++
    #
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#10
    def parse(o, opts = T.unsafe(nil)); end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#42
    def parse_at(o, opts = T.unsafe(nil)); end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#20
    def parse_cron(o, opts = T.unsafe(nil)); end

    # Turns a string like '1m10s' into a float like '70.0', more formally,
    # turns a time duration expressed as a string into a Float instance
    # (millisecond count).
    #
    # w -> week
    # d -> day
    # h -> hour
    # m -> minute
    # s -> second
    # M -> month
    # y -> year
    # 'nada' -> millisecond
    #
    # Some examples:
    #
    #   Rufus::Scheduler.parse_duration "0.5"    # => 0.5
    #   Rufus::Scheduler.parse_duration "500"    # => 0.5
    #   Rufus::Scheduler.parse_duration "1000"   # => 1.0
    #   Rufus::Scheduler.parse_duration "1h"     # => 3600.0
    #   Rufus::Scheduler.parse_duration "1h10s"  # => 3610.0
    #   Rufus::Scheduler.parse_duration "1w2d"   # => 777600.0
    #
    # Negative time strings are OK (Thanks Danny Fullerton):
    #
    #   Rufus::Scheduler.parse_duration "-0.5"   # => -0.5
    #   Rufus::Scheduler.parse_duration "-1h"    # => -3600.0
    #
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#81
    def parse_duration(str, opts = T.unsafe(nil)); end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#27
    def parse_in(o, opts = T.unsafe(nil)); end

    # Alias for Rufus::Scheduler.singleton
    #
    # source://rufus-scheduler//lib/rufus/scheduler.rb#110
    def s(opts = T.unsafe(nil)); end

    # Returns a singleton Rufus::Scheduler instance
    #
    # source://rufus-scheduler//lib/rufus/scheduler.rb#103
    def singleton(opts = T.unsafe(nil)); end

    # Releasing the gem would probably require redirecting .start_new to
    # .new and emit a simple deprecation message.
    #
    # For now, let's assume the people pointing at rufus-scheduler/master
    # on GitHub know what they do...
    #
    # source://rufus-scheduler//lib/rufus/scheduler.rb#118
    def start_new; end

    # Turns a number of seconds into a a time string
    #
    #   Rufus.to_duration 0                    # => '0s'
    #   Rufus.to_duration 60                   # => '1m'
    #   Rufus.to_duration 3661                 # => '1h1m1s'
    #   Rufus.to_duration 7 * 24 * 3600        # => '1w'
    #   Rufus.to_duration 30 * 24 * 3600 + 1   # => "4w2d1s"
    #
    # It goes from seconds to the year. Months are not counted (as they
    # are of variable length). Weeks are counted.
    #
    # For 30 days months to be counted, the second parameter of this
    # method can be set to true.
    #
    #   Rufus.to_duration 30 * 24 * 3600 + 1, true   # => "1M1s"
    #
    # If a Float value is passed, milliseconds will be displayed without
    # 'marker'
    #
    #   Rufus.to_duration 0.051                       # => "51"
    #   Rufus.to_duration 7.051                       # => "7s51"
    #   Rufus.to_duration 0.120 + 30 * 24 * 3600 + 1  # => "4w2d1s120"
    #
    # (this behaviour mirrors the one found for parse_time_string()).
    #
    # Options are :
    #
    # * :months, if set to true, months (M) of 30 days will be taken into
    #   account when building up the result
    # * :drop_seconds, if set to true, seconds and milliseconds will be
    #   trimmed from the result
    #
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#124
    def to_duration(seconds, options = T.unsafe(nil)); end

    # Turns a number of seconds (integer or Float) into a hash like in :
    #
    #   Rufus.to_duration_hash 0.051
    #     # => { :s => 0.051 }
    #   Rufus.to_duration_hash 7.051
    #     # => { :s => 7.051 }
    #   Rufus.to_duration_hash 0.120 + 30 * 24 * 3600 + 1
    #     # => { :w => 4, :d => 2, :s => 1.120 }
    #
    # This method is used by to_duration behind the scenes.
    #
    # Options are :
    #
    # * :months, if set to true, months (M) of 30 days will be taken into
    #   account when building up the result
    # * :drop_seconds, if set to true, seconds and milliseconds will be
    #   trimmed from the result
    #
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#152
    def to_duration_hash(seconds, options = T.unsafe(nil)); end

    # Used by both .to_duration and .to_duration_hash
    #
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#159
    def to_fugit_duration(seconds, options = T.unsafe(nil)); end

    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#181
    def utc_to_s(t = T.unsafe(nil)); end
  end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#31
class Rufus::Scheduler::AtJob < ::Rufus::Scheduler::OneTimeJob
  # @return [AtJob] a new instance of AtJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#33
  def initialize(scheduler, time, opts, block); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#273
class Rufus::Scheduler::CronJob < ::Rufus::Scheduler::RepeatJob
  # @return [CronJob] a new instance of CronJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#277
  def initialize(scheduler, cronline, opts, block); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#301
  def brute_frequency; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#286
  def check_frequency; end

  # Returns the value of attribute cron_line.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#275
  def cron_line; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#311
  def next_time_from(time); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#306
  def rough_frequency; end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#318
  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

# Debugging tools...
#
# source://rufus-scheduler//lib/rufus/scheduler/util.rb#211
class Rufus::Scheduler::D
  class << self
    # source://rufus-scheduler//lib/rufus/scheduler/util.rb#213
    def h_to_s(t = T.unsafe(nil)); end
  end
end

# source://rufus-scheduler//lib/rufus/scheduler.rb#14
Rufus::Scheduler::EoTime = EtOrbi::EoTime

# A common error class for rufus-scheduler
#
# source://rufus-scheduler//lib/rufus/scheduler.rb#26
class Rufus::Scheduler::Error < ::StandardError; end

# A parent class of EveryJob and IntervalJob
#
# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#164
class Rufus::Scheduler::EvInJob < ::Rufus::Scheduler::RepeatJob
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#166
  def first_at=(first); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#172
class Rufus::Scheduler::EveryJob < ::Rufus::Scheduler::EvInJob
  # @return [EveryJob] a new instance of EveryJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#178
  def initialize(scheduler, duration, opts, block); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#193
  def check_frequency; end

  # Returns the value of attribute frequency.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#174
  def frequency; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#201
  def next_time_from(time); end

  # Returns the value of attribute resume_discard_past.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#176
  def resume_discard_past; end

  # Sets the attribute resume_discard_past
  #
  # @param value the value to set the attribute resume_discard_past to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#176
  def resume_discard_past=(_arg0); end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#208
  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

# The standard flock mechanism, with its own class thanks to @ecin
#
# source://rufus-scheduler//lib/rufus/scheduler/locks.rb#21
class Rufus::Scheduler::FileLock
  # @return [FileLock] a new instance of FileLock
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#25
  def initialize(path); end

  # Locking is successful if this Ruby process can create and lock
  # its lockfile (at the given path).
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#33
  def lock; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#64
  def locked?; end

  # Returns the value of attribute path.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#23
  def path; end

  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#59
  def unlock; end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#42
class Rufus::Scheduler::InJob < ::Rufus::Scheduler::OneTimeJob
  # @return [InJob] a new instance of InJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#44
  def initialize(scheduler, duration, opts, block); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#229
class Rufus::Scheduler::IntervalJob < ::Rufus::Scheduler::EvInJob
  # @return [IntervalJob] a new instance of IntervalJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#233
  def initialize(scheduler, interval, opts, block); end

  # Returns the value of attribute interval.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#231
  def interval; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#247
  def next_time_from(time); end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#254
  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#2
class Rufus::Scheduler::Job
  # @return [Job] a new instance of Job
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#46
  def initialize(scheduler, original, opts, block); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#164
  def [](key); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#159
  def []=(key, value); end

  # Calls the callable (usually a block) wrapped in this Job instance.
  #
  # Warning: error rescueing is the responsibity of the caller.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#197
  def call(do_rescue = T.unsafe(nil)); end

  # anything with a #call(job[, timet]) method,
  # what gets actually triggered
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#36
  def callable; end

  # Will fail with an ArgumentError if the job frequency is higher than
  # the scheduler frequency.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#109
  def check_frequency; end

  # Returns the value of attribute count.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#19
  def count; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#177
  def entries; end

  # a reference to the instance whose call method is the @callable
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#40
  def handler; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#169
  def has_key?(key); end

  # Returns the value of attribute id.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#11
  def id; end

  # Returns the value of attribute id.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#11
  def job_id; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#169
  def key?(key); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#175
  def keys; end

  # Kills all the threads this Job currently has going on.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#144
  def kill; end

  # Returns the value of attribute last_time.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#15
  def last_time; end

  # Returns the value of attribute last_work_time.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#20
  def last_work_time; end

  # Returns the value of attribute locals.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#18
  def locals; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#100
  def location; end

  # Returns the value of attribute mean_work_time.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#21
  def mean_work_time; end

  # Returns the value of attribute name.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#23
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#23
  def name=(_arg0); end

  # next trigger time
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#27
  def next_time; end

  # next trigger time
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#27
  def next_time=(_arg0); end

  # might be necessary at some point
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#188
  def next_times(count); end

  # Returns the value of attribute opts.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#12
  def opts; end

  # Returns the value of attribute original.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#13
  def original; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#12
  def params; end

  # previous "next trigger time"
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#31
  def previous_time; end

  # previous "next trigger time"
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#31
  def previous_time=(_arg0); end

  # Default, core, implementation has no effect. Repeat jobs do override it.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#44
  def resume_discard_past=(v); end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#149
  def running?; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#154
  def scheduled?; end

  # Returns the value of attribute scheduled_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#14
  def scheduled_at; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#100
  def source_location; end

  # Returns the value of attribute tags.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#17
  def tags; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#137
  def threads; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#114
  def trigger(time); end

  # Trigger the job right now, off of its schedule.
  #
  # Done in collaboration with Piavka in
  # https://github.com/jmettraux/rufus-scheduler/issues/214
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#127
  def trigger_off_schedule(time = T.unsafe(nil)); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#132
  def unschedule; end

  # Returns the value of attribute unscheduled_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#16
  def unscheduled_at; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#176
  def values; end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#204
  def callback(meth, time); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#214
  def compute_timeout; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#228
  def do_call(time, do_rescue); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#247
  def do_trigger(time); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#223
  def mutex(m); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#296
  def post_trigger(time); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#304
  def start_work_thread; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#267
  def trigger_now(time); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#354
  def trigger_queue(time); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#4
Rufus::Scheduler::Job::EoTime = EtOrbi::EoTime

# Used by Job#kill
#
# source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#9
class Rufus::Scheduler::Job::KillSignal < ::StandardError; end

# The array rufus-scheduler uses to keep jobs in order (next to trigger
# first).
#
# source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#6
class Rufus::Scheduler::JobArray
  # @return [JobArray] a new instance of JobArray
  #
  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#8
  def initialize; end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#52
  def [](job_id); end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#41
  def delete_unscheduled; end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#26
  def each(now, &block); end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#14
  def push(job); end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#21
  def size; end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#47
  def to_a; end

  # source://rufus-scheduler//lib/rufus/scheduler/job_array.rb#57
  def unschedule_all; end
end

# MIN_WORK_THREADS = 3
#
# source://rufus-scheduler//lib/rufus/scheduler.rb#40
Rufus::Scheduler::MAX_WORK_THREADS = T.let(T.unsafe(nil), Integer)

# For when the scheduler is not running
# (it got shut down or didn't start because of a lock)
#
# source://rufus-scheduler//lib/rufus/scheduler.rb#37
class Rufus::Scheduler::NotRunningError < ::Rufus::Scheduler::Error; end

# A lock that can always be acquired
#
# source://rufus-scheduler//lib/rufus/scheduler/locks.rb#8
class Rufus::Scheduler::NullLock
  # Locking is always successful.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#12
  def lock; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#14
  def locked?; end

  # source://rufus-scheduler//lib/rufus/scheduler/locks.rb#15
  def unlock; end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#2
class Rufus::Scheduler::OneTimeJob < ::Rufus::Scheduler::Job
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#6
  def occurrences(time0, time1); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_core.rb#27
  def time; end

  protected

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#13
  def determine_id; end

  # There is no next_time for one time jobs, hence the false.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_one_time.rb#25
  def set_next_time(trigger_time, is_post = T.unsafe(nil), now = T.unsafe(nil)); end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#2
class Rufus::Scheduler::RepeatJob < ::Rufus::Scheduler::Job
  # @return [RepeatJob] a new instance of RepeatJob
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#10
  def initialize(scheduler, duration, opts, block); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#105
  def determine_id; end

  # Returns the value of attribute first_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#6
  def first_at; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#34
  def first_at=(first); end

  # Returns the value of attribute last_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#7
  def last_at; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#55
  def last_at=(last); end

  # Starting from now, returns the {count} next occurences
  # (EtOrbi::EoTime instances) for this job.
  #
  # Warning, for IntervalJob, the @mean_work_time is used since
  # "interval" works from the end of a job to its next trigger
  # (not from one trigger to the next, as for "cron" and "every").
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#142
  def next_times(count); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#114
  def occurrences(time0, time1); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#88
  def pause; end

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#100
  def paused?; end

  # Returns the value of attribute paused_at.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#4
  def paused_at; end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#93
  def resume(opts = T.unsafe(nil)); end

  # Returns the value of attribute times.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#8
  def times; end

  # Sets the attribute times
  #
  # @param value the value to set the attribute times to.
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#8
  def times=(_arg0); end

  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#73
  def trigger(time); end

  protected

  # @return [Boolean]
  #
  # source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#151
  def discard_past?; end
end

# source://rufus-scheduler//lib/rufus/scheduler/jobs_repeat.rb#32
Rufus::Scheduler::RepeatJob::FIRSTS = T.let(T.unsafe(nil), Array)

# This error is thrown when the :timeout attribute triggers
#
# source://rufus-scheduler//lib/rufus/scheduler.rb#31
class Rufus::Scheduler::TimeoutError < ::Rufus::Scheduler::Error; end

# source://rufus-scheduler//lib/rufus/scheduler.rb#12
Rufus::Scheduler::VERSION = T.let(T.unsafe(nil), String)
